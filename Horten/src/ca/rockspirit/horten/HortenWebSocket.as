package ca.rockspirit.horten{	import com.worlize.websocket.WebSocket;	import com.worlize.websocket.WebSocketEvent;		import flash.events.IOErrorEvent;	import flash.utils.getTimer;	import flash.utils.setInterval;	import flash.utils.setTimeout;		public class HortenWebSocket extends HortenListener	{		protected var _pushData:Object;				protected var _pullPaths:Array;		protected var _url:String;				// Delay before attempting to reconnect, in milleseconds		public var retryDelay:int = 1000;				// Delay before sending values to the server.		// This time delay allows touched values to be		// accumulated and sent as one packet, rather		// than a ton of individual calls.		// I assume that values less that 1000 / frameRate		// should be sent the next frame.		public var pushDelay:int = 1;				public var keepAlive:Boolean = true;				public function HortenWebSocket( url:String, localPath:* = '/', horten:Horten = null )		{			_url = url;						super( localPath, remotePath, false, horten );						connect ();		}				/** Queue a path to be pulled down from the server. Called without a		 * path, this will pull all the data we have responsibility for.		 * 		 * This is useful for retrieving our entire state from the server upon		 * connection, and can be called before the connection is		 * established.		 * 		 * Usage in combination with push() is not recommended, whether		 * the server's version or local version is used is undefined.		 */		public function pullFromServer ( path:String = null ):void {			if ( path == null )				path = _hortenPath;			else 				path = Horten.pathString( path );						path = this.localToRemotePath( path );						if ( !_pullPaths )				_pullPaths = [];						if ( _pullPaths.indexOf( path ) == -1 )				_pullPaths.push( path );						_pullNow ();		}				/** Queue a path to be pushed to the server. This will send all		 * values under this path, whether or not they're been changed		 * locally. If a path is not specified, this will send all		 * data we have responsibility for ( defined by localPath and		 * remotePath ).		 * 		 * This is useful for sending our entire state to the server upon		 * connection, and can be called before the connection is		 * established.		 * 		 * Usage in combination with pull() is not recommended, whether		 * the server's version or local version is used is undefined.		 */		public function pushToServer ( path:String = null ):void {			if ( path == null )				path = _hortenPath;			else 				path = Horten.pathString( path );						if ( !_pushData )				_pushData = {};						_pushData[path] = Horten.FILL_DATA;		}						public function close ():void {			keepAlive = false;			ws = null;						if ( _horten ) {				_horten.removeListener( this );			}		}				//	--------------------------------		//	Getters For Read-only Properties		//	--------------------------------						public function get localPath ():String 		{			return _hortenPath;		}				public function get remotePath ():String 		{			return _myPath;		}				//	----------------		//	Data from Horten		//	----------------				override internal function setFromHorten( path:String, value:*, pathIsLocal:Boolean = false ):void		{			path = Horten.pathString( path );						if ( !_pushData )				_pushData = {};						_pushData[ path ] = value;						_pushDelay();		}				//	---------		//	WebSocket		//	---------				protected var _ws:WebSocket;				// Whether a call has already been made to delayConnect		protected var _connectDelay:Boolean;				protected function delayConnect ():void {			if ( retryDelay > 0 ) {				if ( !_connectDelay ) {					flash.utils.setTimeout( connect, retryDelay );					_connectDelay = true;				}			} else {				connect ();			}		}				protected function connect ():void {			ws = new WebSocket ( _url, '*', 'horten-protocol' );			_ws.connect();			_connectDelay = false;		}				/** Add and remove event listeners on WebSocket */		protected function set ws ( newWS:WebSocket ):void {			if ( _ws ) {				_ws.removeEventListener( IOErrorEvent.IO_ERROR,	onWebSocketIOError );				_ws.removeEventListener( WebSocketEvent.OPEN, 		onWebSocketOpen );				_ws.removeEventListener( WebSocketEvent.CLOSED, 	onWebSocketClose );				_ws.removeEventListener( WebSocketEvent.MESSAGE, 	onWebSocketMessage );								if ( _ws.connected )					_ws.close( false );			}						_ws = newWS;						if ( _ws ) {				_ws.addEventListener( IOErrorEvent.IO_ERROR,	onWebSocketIOError );				_ws.addEventListener( WebSocketEvent.OPEN, 		onWebSocketOpen );				_ws.addEventListener( WebSocketEvent.CLOSED, 	onWebSocketClose );				_ws.addEventListener( WebSocketEvent.MESSAGE, 	onWebSocketMessage );			}		}				protected function sendObject ( ob:* ):void {			var json:String = JSON.stringify( ob );			_ws.sendUTF( json );		}				//	------------------------		//	WebSocket Event Handlers		//	------------------------				protected function onWebSocketIOError ( e:IOErrorEvent ):void {			if ( keepAlive ) {				delayConnect ();			} else {				close ();			}		}				protected function onWebSocketOpen ( e:WebSocketEvent ):void {			_pushNow ();			_pullNow ();		}				protected function onWebSocketClose ( e:WebSocketEvent ):void {			if ( keepAlive ) {				delayConnect ();			} else {				close ();			}		}				protected function onWebSocketMessage ( e:WebSocketEvent ):void {						//trace ( "Websocket in", e.message.utf8Data );			if ( e.message ) {				var json:String = e.message.utf8Data;				try {					var ob:Object = JSON.parse( json );									} catch ( e:Error ) {					throw ( new Error ( 'Bad JSON in incoming message' ) );				}								if ( ob['set'] ) {					var remoteData:Object = ob['set'];					var set:Object = {};					for ( var remotePath:String in remoteData ) {						var localPath:String = this.remoteToLocalPath( remotePath );						Horten.flattenObject( remoteData[remotePath], localPath, set ); 					}					_horten.setMultiple( set, this );				}			}		}						//	--------------------		//	Push & Pull Plumbing		//	--------------------				protected function _pullNow ():void {			if ( !_ws || !_ws.connected )				return;						if ( !_pullPaths || !_pullPaths.length )				return;									sendObject ( {				get: _pullPaths			} );						_pullPaths = null;		}				/** 		 * Declare that data need to be pushed to the server, either immediately or pretty quick.		 */				protected var _pushIsDelayed:Boolean;		protected function _pushDelay ():void {			if ( pushDelay > 0 ) {				if ( !_pushIsDelayed ) {					_pushIsDelayed = true;					setTimeout ( _pushNow, pushDelay );				}								} else {				_pushNow ();			}		}				protected function _pushNow ():void {						_pushIsDelayed = false;						if ( !_ws || !_ws.connected )				return;						if ( !_pushData )				return;						var set:Object = {};			var somethingToSend:Boolean = false;						for ( var localPath:String in _pushData ) {				var remotePath:String = localToRemotePath ( localPath );				set[ remotePath ] = _pushData[localPath] == Horten.FILL_DATA ? _horten.get ( localPath ) : _pushData[localPath]; 				somethingToSend = true;			}						if ( somethingToSend ) {				sendObject ( { set: set } );			}						_pushData = null;					}	}}